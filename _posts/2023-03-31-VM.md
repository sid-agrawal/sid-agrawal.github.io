---
layout: posts
title:  "Virtual Machines and the spectrum of Isolation"
date: 2023-03-31
categories: virtualization, microkernels
---

We think of virtual machines as an abstraction of the underlying hardware.
But I claim that this is far from the truth.


## What can a CPU do?
A CPU is meant to execute the user's code, and any time it spends running Operating System(OS),
or Hypervisor(HV) code is a waste of time.
But there are some instructions we only want the OS/HV to execute, and we call them privileged instructions.
The CPU can execute these privileged instructions only when the CPU is in a higher privileged mode.

In a simplistic view of a CPU, there are only two modes, viz. user and kernel.
Some instructions can be executed only in kernel mode and some in both user and kernel mode.

In a more complete view, there are three modes viz. user, kernel and hypervisor.
The relationship is better described by the diagram below.

![Types of Instructions](../images/instruction-set-venn-diagram.png)


## What does an OS do?
One of the jobs of the OS is to intercept instructions that
the user-program is not supposed to execute.

And similarly for the hypervisor.

## What about the application?
Let's look at how things look from the point of view of the
application running directly on the OS(on baremetal) or inside a VM.

**Normal Case**: Every time the user application generates a fault, the OS is invoked.
The OS does what action it needs to take and then delegates the the control back to the process.
The `action` can be update some state the OS is maintaining for the process, or just kill it.

**VM Case**: Now when a user application generates a fault, `conceptually` the control is given to the guest OS.
But in practise, the hardware still delegates control to the hostOS(aka Hypervisor), the hypervisor then determines
that this instruction is from a process inside a guestOS and then relay that information to the guestOS along
with information about the fault(type and PC at the least). The guestOS then does the same things as above.

<Talk about the state maintainted>





## Thinking of in terms of independent protection domains.
In the **Normal Case**, the OS and the process running on it are two separate protection domains. <define PD>.
All faults of the process are related to the OS.


In the **Virtualization Case**, the hostOS, the guestOS and the processG(inside the guest) are three separate PDs.
All faults from the guestOS are relayed to the hostOS, and all the faults from the processG are related to the guestOS.



## My gripe with how we think of VMs
When we think of the processG, `conceptually` we think of it as running inside a guestOS, but I would like to argue
that that the processG is simply running on the hostOS, and its just that all its faults are related to the guestOS for resolution.

### What does it mean when we say that "processG is running inside the guestOS"?

1. It means that the information about the processG (its memory map, scheduling info, open handles)
is kept inside the guestOS and the hostOS is not aware of its existence.

2. The processG itself cannot query any system state outside the guestOS.

3. The schedulable entity from the point of view of the hostOS is the guestOS.


### What does it mean when we say that "processG is running on the hostOS, but all its faults are relayed to the guestOS?

1. The hostOS is aware of the existence of the processG, and at least of its data structures
2. We will forward all the requests from processG, to the guestOS, so this stays the same.
3. The schedulable entity from the point of view of the hostOS is the processG. But again this is a choice and doesn't have to be this way.
We can treat the guestOS and the processes it handles as a scheduling group.


I think that we can achieve 1 and 3, by simply ...

But 2, is a bit tricky.



## Where do Virtualization Acceleration fit into all this?
Without any virtualization assitance from the hardware every fault generated by the guest process is trapped to the
hostOS. But with virtualization accelerators (like VT-X), we can program to directly trap some of the faults to the
guestOS and thus bypassing the hostOS.


