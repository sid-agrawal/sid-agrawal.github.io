# Experience Paper: seL4 + CHERI

## Sidhartha Agrawal

```
ARM & University of British Columbia sid@sid-agrawal.ca
Draft Do Not circulate
```
## 1 INTRODUCTION

```
PARACHERI is an architectural extension that adds HW capabili-
ties to modern processors.
PARATo aid the incremental adoption of CHERI hardware, two
compilation modes are supported: hybrid and purecap.
PARAMorello is the ARM implementation of CHERI [I think
this paragraph ends with ’ARM’s secure enclave, TrustZone, uses
the capability-based microkernel, seL4.’]
PARAARM’s TrustZone uses seL4 because it is formally verified.
Since seL4 is formally verified, it might not benefit from CHERI
capabilities, but the user application running on seL4 will still
benefit.
PARAWith the release of Morello, we ask whether we can
securely extend the ARM TrustZone TCB to include user-level code
using CHERI capabilities.
PARAseL4 capabilities capabilities are enforced via system calls
into the seL4 microkernel, while CHERI capabilities simply limit
operations upon virtual addresses. [This paragraph should explain
how this mismatch is fundamental to the problem being discussed
in this paper.]
PARAThe model CheriBSD provides for implementing an oper-
ating system on CHERI is not well matched to seL4, as CheriBSD is
a monolithic kernel and seL4 is a monolithic kernel. [In particular,
CheriBSD’s monolithic architecture does not require passing capa-
bilities between processes, while seL4’s microkernel architecture
makes passing capabilities a hard requirement.]
PARAWe designed a three-stage effort to port seL4 to Morello.
(1)Run a hybrid userspace application. We do this because it
requires minimal change to the userspace, but it still requires
kernel changes.
(2)Run a purecap userspace application which will require port-
ing of the userspace libraries.
(3)Explore the mapping of CHERI caps to seL4 caps. We decided
that this was not the right thing to do.
To date, we have completed the first two stages. We successfully
use CHERI capabilities within TrustZone and identify challenges
that must be met to complete Stage 3.
```
## 2 BACKGROUND

This work lies at the intersection of capability-based microkernel
and capability in hardware. In this section, we describe seL4 – a
capability-based microkernel, and CHERI – a hardware platform
with capability enabled instructions.

## 2.1 seL

```
PARASeL4 is a formally verified capability-based microkernel.
PARAIn capability based system, access to system resources is
granted by unforgeable tokens called capabilities.
PARAIn a microkernel, most functionality provided by a typical
monolithic kernel is provided by user space servers.
```
## 2.2 CHERI

```
PARACHERI (CapabilityHardwareEnabledRISCInstruction)
is a hardware instruction set extension that provided hardware
capabilities.
CHERI capabilities are 128 bits in size. They contain a virtual
address, size of the accessible region, and permission with which
that region can be accessed. CHERI protects its pointers, by en-
forcing three properties –provenance, integrity, and monotonicity.
Provenancemeans that capabilities can only be derived from other
valid capabilities and cannot be forged from an address.Integrity
means that capabilities stored in memory cannot be modified. This
is achieved by using tagged memory.Monotonicityrequires that,
when a capability is stored in a register, it is only possible to reduce
its bounds and permissions, e.g., a read-only capability cannot be
turned into a read-write one.
Sealed Capabilities:CHERI capabilities have asealed bitin the
128 bits. When this bit is set, the capability can be neither sealed
nor changed. [Further describe how sealing and unsealing is done]
```
## 3 EXPERIENCE AND LESSONS

```
PARAOur port of seL4 to Morello proceeded in three stages. Next,
we describe the three stages and the lesson learned in each stage.
```
## 3.1 Hybrid Userspace

```
PARA: Hybrid userspace does not need changes in user applica-
tions, but still requires changes in the kernel.
PARARegardless of the mode of compilation of the application,
the operating system must be changed to ensure that the new
registers are saved. Also, memory must be configured so that it
does not cause failure in capability loads and stores. More details
are presented in Appendix A.
PARACheriBSD is an adequate guide for this.
```
## 3.2 Purecap Userspace

```
PARATo take advantage of the spatial memory safety provided by
CHERI the end goal is to compile the application inPurecapmode.
[Describe advantages of purecap]
PARAUnlike the hybrid mode, CheriBSD did not provide an
adequate reference for the seL4 port. CheriBSD allows the kernel
to pass capabilities to the user space and vice versa via a system
call. However, since passing pointers via IPC is not essential to the
operation of a monolithic kernel, CheriBSD does not support it.
PARAIt is also not a good idea for two user processes to ex-
change CHERI capabilities with the mediation from the kernel.
Since CHERI capabilities are just virtual addresses and not tied to a
particular address space, this would mean that two colluding pro-
cesses could grow the range of virtual addresses they have access
to.
PARAIPC is necessary in a microkernel, as most of the system
call like features are implemented in user processes. See Figure 1
```

```
Figure 1:Purecap Application: Pointers are CHERI caps
```
```
Figure 2:seL4: new permissions for endpoints
```
PARASo, we plan to extend the IPC mechanism in seL4. We
will add new permissions to the endpoint capability in seL4 to
allow/prevent sharing of CHERI capabilities via IPC. See Figure 2
and Figure 3.
PARASealed capabilities are CHERI capabilities that cannot be
dereferenced. A CHERI capability (say, a pointer to an array) can be
sealed with another CHERI capability (called a sealing capability).
Once sealed, the capability to the array cannot be deferenced unless
it is unsealed by the original sealing capability.
PARACheriBSD splits its sealing cap range into only two ranges,
since there is only a user and a kernel. But in an uKernel system,
we have the kernel, system services, and user applications, so we
need to split the sealed caps into at least three ranges. Figure 4
PARAWhen the CPU boots up, a root capability is put in a
well-known register. This root capability has access to the entire
virtual address range with all permissions.
PARACheriBSD keeps this root capability in the kernel and
gives a limited capability to the userspace. But we give the root
CHERI cap to root-task to mimic what seL4 does with seL4 caps.
[Sid:I feel like this is the right thing to do, but I do not have a good
reason]. In seL4, the root-task gets the capabilities to any memory
not used by the kernel. The kernel does not make any caps to the
memory it uses during boot. Therefore, the root task has all the
available seL4 capabilities in the system. In that spirit, we hand
over the root CHERI capability to the root-task.

```
Figure 3:Purecap Application: Restricted Endpoints
```
```
Figure 4:Fine Grained Sealing Cap ranges
```
## 3.3 CHERI Vs. seL4 capabilities

```
PARACapabilities in seL4 are tokens for calling methods on system
objects. They are implemented in the kernel using the system call
mechanism.
PARARevocation is an important feature of the seL4 capability
model, and the kernel maintains aCavailabilityDerivationTree
(CDT) to assist in revocation.
PARACHERI capabilities do not maintain a derivation tree. For
example, two capabilities for the same array are independent, and
there is no single palace to revoke it, short of scanning the entire
memory range.
PARAWe summarize these differences in Table 1. [Sid(TODO):
Discuss how Propagation, Restriction, Recovation .. works in both]
Due to these fundamental differences, the CHERI capabilities are
not a drop in replacement for the seL4 capabilities.
PARAExample of parts of the seL4 capability system that can
be augmented with CHERI capabilities.
```
- Sealed Capabilitiesinstead of the C-slot identifiers. [Sid(TODO):
    Describe potential Pros and Cons]
- Using Sealed Capabilities for control-flow transfer from ker-
    nel to userspace. [Sid(TODO):Describe potential Pros and
    Cons. It would also make seL4 a SASOS]
PARAThough we can implement parts of the seL4 capability
model using the CHERI instructions. It is unclear whether 1) there
will be a performance improvements, 2) since it would mean that

### 2


```
Table 1:Comparing seL4 and CHERI caps
CHERI seL
In simple terms, A fat pointer to a Virtual Address range A token to do an operation on a system resource
Implementation Layer Hardware Kernel
Propagation Trivial: Register Load/Store Trivial: Mint via kernel
Restriction Trivial: Register operation Trivial: Retype via kernel
Revocation Hard: Scan all of the memory Trivial: Scan all CDT
Accessibility Hard: Scan all of the memory Moderate: Scan all cap lists
Protection Domain All Caps in accessible memory All caps in the CSpace
```
we are heading towards a SASOS, would it still be seL4 after the
changes.

## 4 EVALUATION

```
[Sid:Calling it evaluation feels weird. Thoughts?]
```
## 4.1 Performance

PARASince we have done QEMU development work, which is not
cycle accurate, we did not collect performance numbers. Instead,
we calculate the number of extra instructions required for each
operation and the extra memory usage due to larger registers.
PARA[Sid(TODO):Find and cite details(if any) of performance
numbers of these new instructions and additional cache pressure.]

## 4.2 Developer Effort

```
So far, we have spent approximately four months of full-time devel-
opment effort between two developers. We spent most of the initial
time understanding the details of seL4 boot-up, context-switch, and
process startup code. Similarly, time was spent understanding the
intricacies of the CHERI capabilities and setting up the toolchain to
compile seL4 with CHERI. So far, we have modified about 500 lines
of code. For context, the kernel is about 10K LoC and the userspace
is 50K LoC. About 30% of the LoC are in the ARM assembly, and
the rest are in C.
```
## 4.3 Impact on Formal Verification

We added our changes to theaarch64platform-specific code of
seL4, invalidating the formal verification of seL4. [Sid(TODO):
Double check with Gerwin Klein from sel4-dev that this is true.]
We have tried to keep the changes in the kernel to the most essential.
But do not have a good sense of how much effort is needed to re-
verify the kernel.

## 5 SUMMARY

```
This work enables C/C++ user applications on seL4 to use CHERI
features and get additional security guarantees. We also looked at
using CHERI capabilities as a replacement for seL4 capabilities and
concluded that they are fundamentally different. Our work provides
a valuable contribution to the growing body of work on porting
systems software to the CHERI processor, which provides security
guarantees.
```
## REFERENCES

## A APPENDIX

## A.1 Kernel Changes for Hybrid Userspace

- Enable Morello instructions, without which every new Morello
    instruction will fail.
- Enable the loading and storage of CHERI capabilities in mem-
    ory.
- Update the context-switch code to save and restore new
    registers.
- Update system calls to handle new registers. [Sid(TODO):
    Add, update how?]
- Setup andProgram Counter Capability(PCC) andDefault
    Data Capability(DDC) when starting a new process.
- Pass part of theMAX_CAPto the user process.

### 3


